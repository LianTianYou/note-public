---
title: 4. 容器
---

# 4. 容器

# array

> 头文件：#include <array>

使用 array 模板类创建：

```c
array<数据类型, 长度> 变量名 = {xx, xx, xx};
```

array 和数组的对比：

- array 和数组一样，可以通过下标取值。
- array 可以整体赋值（值拷贝）：`数组1 = 数组2`
- array 是一个对象，可以调用方法。

相关方法：

```c
.size()			// 获取长度
.fill(value)	// 使用相同的值填充数组	
```

# vector

vector 是一个动态长度的数组。

> 头文件：#include <vector>

定义方式：

```c
vector<数据类型> 变量名;		// 创建一个空容器

// 指定元素内容
vector<数据类型> 变量名 =  {1, 2, 3};
vector<数据类型> 变量名 {1, 2, 3};

// 通过构造函数初定义
vector<数据类型> 变量名(length);				// 指定元素个数（默认全为 0）
vector<数据类型> 变量名(length, default)		// 指定元素个数和默认值
vector<数据类型> 变量名(对象);				// 拷贝另一个 vecotr 对象的值
```

取值：

```c
变量[index]
```

相关方法：

```c
.size()			// 获取元素个数
.at(index)		// 获取指定位置的元素
    
.push_back()	// 在末尾添加元素
.pop_back()		// 删除末尾元素
.clear()		// 清空容器
.empty()		// 判断是否为空
```

vector 对比 list：

- vector 底层是动态数组，list 底层是双链表。
- vector 的访问速度更快。

# pair 对组

创建对组：

```cpp
pair<数据类型, 数据类型> 变量名(value1, value2);

pari<数据类型, 数据类型> 变量名 = make_pair(value1, value2);
```

相关操作：

```cpp
.first			// 获取第一个元素
.second			// 获取第二个元素
```

# map

> 头文件：#include <map>

关于 map：

- map 中的所有元素都是 pair。
- map 通过 key 获取 value。
- map 中的所有元素按键值自动排序。
- 底层通过二叉树实现。

创建 map：

```cpp
map<数据类型, 数据类型> 变量;

map<string, string> myMap = {
	{"name", "root"},
	{"pwd", "root"}
}
```

插入 key：

```cpp
变量[key] = value;
.insert(pair<type, type>(value1, value2))		// 插入一个 pair
.insert(make_pair(key, value))					// 插入一个 pair
```

相关方法：

```cpp
.insert(value)			// 插入值
[key]					// 通过 key 获取 value
.at(key)				// 通过 key 获取 value
.size()					// 获取大小
.empty()				// 判断是否为空
.clear()				// 清空容器
.erase(key)				// 通过 key 删除元素
.count(key)				// 统计出现次数（判断 key 是否存在）
.find(key)				// 查找元素，返回迭代器，不存在返回.end()
```

判断元素是否存在：

```cpp
if (myMap.count("apple") > 0) {
    // 元素存在
} else {
    // 元素不存在
}

```

查找元素：

```cpp
auto iter = myMap.find("banana");  // 查找指定键的元素
if (iter != myMap.end()) {
    // 找到了元素
    int value = iter->second;  // 获取值
} else {
    // 未找到元素
}
```

# unordered_map

unordered 对比 map：

- 底层：unordered 底层基于哈希表，map 底层基于红黑树。
- 排序：map 会对 key 进行排序，unordered_map 是无序的。
- 查找效率：unordered_map（哈希表）的查找效率为常数级，map（红黑树）的查找效率为对数级。
- 内存消耗：为了维持红黑树的结构，map 比 unordered_map 占用的内存更多。
- 稳定性：unordered_map 的迭代器在插入、删除元素后可能会失效，map 则能保持稳定。

创建 unordered_map：

```cpp
unordered_map<数据类型, 数据类型> 变量;
```

插入元素：

```cpp
变量[key] = value;
```

# 迭代器

创建迭代器类型的变量：

```cpp
vector<int>::iterator it;
```

获取迭代器的开始位置：

```cpp
容器.begin()
```

获取迭代器的结束位置：

```cpp
容器.end()
```

移动迭代器：

```cpp
it++;
```

获取当前元素：

```cpp
*it;
```

使用迭代器遍历：

```cpp
for (vector<int>::iterator it - vec.begin(); it != vec.end(); i++) {
    cout << * it;
}
```
